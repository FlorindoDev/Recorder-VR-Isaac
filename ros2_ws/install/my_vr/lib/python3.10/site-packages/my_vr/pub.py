#!/usr/bin/env python3
"""
ROS2 Humble node to read OpenVR controller data and publish it on a topic.

This node initializes the OpenVR runtime as a Scene application, queries all tracked devices,
filters for controllers, reads their joystick axes, trigger values, and spatial positions,
and publishes these values as Float32MultiArray on `/openvr/controller`.
"""
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray
import openvr


def get_controller_states(vr_system):
    """
    Query all tracked devices and return a list of controller states.

    Each entry is a tuple: (device_index, axis_x, axis_y, trigger_value).
    """
    states = []
    for device_index in range(openvr.k_unMaxTrackedDeviceCount):
        if vr_system.getTrackedDeviceClass(device_index) == openvr.TrackedDeviceClass_Controller:
            got_state, state = vr_system.getControllerState(device_index)
            if got_state:
                axis_x = state.rAxis[0].x
                axis_y = state.rAxis[0].y
                trigger = state.rAxis[1].x
                states.append((device_index, axis_x, axis_y, trigger))
    return states


class OpenVRPublisher(Node):
    def __init__(self):
        super().__init__('openvr_publisher')
        self.pub = self.create_publisher(Float32MultiArray, 'openvr/controller', 10)

        # 1) Inizializza OpenVR come Scene Application
        openvr.init(openvr.VRApplication_Scene)
        self.vr_system = openvr.VRSystem()
        self.compositor = openvr.VRCompositor()

        # 2) Pre-alloca le liste per le pose
        max_devices = openvr.k_unMaxTrackedDeviceCount
        self.render_poses = [openvr.TrackedDevicePose_t() for _ in range(max_devices)]
        self.game_poses   = [openvr.TrackedDevicePose_t() for _ in range(max_devices)]

        # 3) Timer a 10 Hz
        self.timer = self.create_timer(0.1, self.timer_callback)
        self.get_logger().info('OpenVRPublisher initialized (Scene App), publishing every 0.1s')

    def timer_callback(self):
        # Prepara il messaggio
        msg = Float32MultiArray()
        data = []

        # a) Input analogici
        states = get_controller_states(self.vr_system)

        # b) Pose spaziali tramite Compositor
        poses, _ = self.compositor.waitGetPoses(self.render_poses, self.game_poses)

        # c) Costruisci l'array
        for idx, axis_x, axis_y, trigger in states:
            # input stick/trigger
            data.extend([float(idx), axis_x, axis_y, trigger])

            # posizione: estrai la matrice di tracking
            pose = poses[idx]
            if pose.bPoseIsValid:
                m = pose.mDeviceToAbsoluteTracking
                px, py, pz = m[0][3], m[1][3], m[2][3]
            else:
                px = py = pz = float('nan')
            data.extend([px, py, pz])

        msg.data = data
        self.pub.publish(msg)
        self.get_logger().debug(f'Published controller data: {data}')

    def destroy_node(self):
        openvr.shutdown()
        super().destroy_node()


def main(args=None):
    rclpy.init(args=args)
    node = OpenVRPublisher()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Keyboard interrupt received, shutting down')
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
